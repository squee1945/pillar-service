package devhelpermcp

import (
	"context"
	"errors"
	"fmt"
	"io"
	"os"
	"strings"

	"cloud.google.com/go/storage"
	"google.golang.org/adk/tool"
	"google.golang.org/api/iterator"
	"google.golang.org/api/option"
	"google.golang.org/genproto/googleapis/grafeas/v1"
	"google.golang.org/protobuf/encoding/protojson"

	cloudbuild "cloud.google.com/go/cloudbuild/apiv1/v2"
	cloudbuildpb "cloud.google.com/go/cloudbuild/apiv1/v2/cloudbuildpb"
	containeranalysis "cloud.google.com/go/containeranalysis/apiv1"
)

const (
	maxLogs       = 10 * 1024 * 1024
	maxTestOutput = 10 * 1024 * 1024
)

type createCloudBuildInput struct {
	CloudBuildJSON string `json:"cloud_build_json" jsonschema:"Serialized JSON for the cloudbuild.json.`
	Owner          string `json:"source_owner" jsonschema:"The owner of the source repo."`
	Repo           string `json:"source_repo" jsonschema:"The name of the source repo.`
	Commit         string `json:"source_commit" jsonschema:"The commit sha to clone the repo at."`
}

func (i createCloudBuildInput) validate() error {
	var errs []error
	if i.CloudBuildJSON == "" {
		errs = append(errs, errors.New("cloud_build_json is required."))
	}
	if i.Owner == "" {
		errs = append(errs, errors.New("source_owner is required."))
	}
	if i.Repo == "" {
		errs = append(errs, errors.New("source_repo is required."))
	}
	if i.Commit == "" {
		errs = append(errs, errors.New("source_commit is required."))
	}
	return errors.Join(errs...)
}

type createCloudBuildOutput struct {
	BuildID string `json:"build_id" jsonschema:"The Build ID of the created build.`
}

func (d *dh) createCloudBuildTool(ctx tool.Context, input createCloudBuildInput) (createCloudBuildOutput, error) {
	if err := input.validate(); err != nil {
		return createCloudBuildOutput{}, err
	}

	fmt.Fprintln(os.Stderr, "=== cloudbuild.jason (as passed by Gemini) =======================================")
	fmt.Fprintln(os.Stderr, input.CloudBuildJSON)
	fmt.Fprintln(os.Stderr, "==================================================================================")

	var build cloudbuildpb.Build
	if err := protojson.Unmarshal([]byte(input.CloudBuildJSON), &build); err != nil {
		return createCloudBuildOutput{}, fmt.Errorf("json.Unmarshal: %w", err)
	}

	// Output the cloudbuild.jason for debugging.
	marshaler := protojson.MarshalOptions{
		UseProtoNames: true,
		Indent:        "  ",
	}
	cbjson, err := marshaler.Marshal(&build)
	if err != nil {
		return createCloudBuildOutput{}, fmt.Errorf("marshalling build: %w", err)
	}
	fmt.Fprintln(os.Stderr, "=== cloudbuild.json (as generated by Gemini, after marshalling) ==================")
	fmt.Fprintln(os.Stderr, string(cbjson))
	fmt.Fprintln(os.Stderr, "==================================================================================")

	if build.Options == nil {
		build.Options = &cloudbuildpb.BuildOptions{}
	}

	if build.Artifacts == nil || len(build.Artifacts.GoModules) == 0 {
		return createCloudBuildOutput{}, errors.New("missing required artifacts.goModules block")
	}

	build.Options.LogStreamingOption = cloudbuildpb.BuildOptions_STREAM_ON
	build.Options.Logging = cloudbuildpb.BuildOptions_GCS_ONLY
	build.Options.RequestedVerifyOption = cloudbuildpb.BuildOptions_VERIFIED
	build.LogsBucket = "gs://" + d.SubBuildLogsBucket
	build.ServiceAccount = d.SubBuildServiceAccount
	build.Source = &cloudbuildpb.Source{
		Source: &cloudbuildpb.Source_GitSource{
			GitSource: &cloudbuildpb.GitSource{
				Url:      fmt.Sprintf("https://github.com/%s/%s", input.Owner, input.Repo),
				Revision: input.Commit,
			},
		},
	}

	client, err := cloudBuildClient(ctx, d.Region)
	if err != nil {
		return createCloudBuildOutput{}, err
	}
	defer client.Close()

	createReq := &cloudbuildpb.CreateBuildRequest{
		Parent: fmt.Sprintf("projects/%s/locations/%s", d.ProjectID, d.Region),
		Build:  &build,
	}

	op, err := client.CreateBuild(ctx, createReq)
	if err != nil {
		return createCloudBuildOutput{}, fmt.Errorf("client.CreateBuild failed: %w", err)
	}

	metadata, err := op.Metadata()
	if err != nil {
		return createCloudBuildOutput{}, fmt.Errorf("failed to get operation metadata: %w", err)
	}

	buildID := metadata.GetBuild().GetId()

	return createCloudBuildOutput{BuildID: buildID}, nil
}

type getCloudBuildInput struct {
	BuildID string `json:"build_id" jsonschema:"The Build ID of the build.`
}

func (i getCloudBuildInput) validate() error {
	var errs []error
	if i.BuildID == "" {
		errs = append(errs, errors.New("build_id is required."))
	}
	return errors.Join(errs...)
}

type getCloudBuildOutput struct {
	BuildID   string `json:"build_id" jsonschema:"The Build ID of the build.`
	Status    string `json:"status" jsonschema:"The build status.`
	BuildJSON string `json:"build_json" jsonschema:"The build details, as serialized JSON`
}

func (d *dh) getCloudBuildTool(ctx tool.Context, input getCloudBuildInput) (getCloudBuildOutput, error) {
	if err := input.validate(); err != nil {
		return getCloudBuildOutput{}, err
	}

	build, err := getCloudBuild(ctx, d.ProjectID, d.Region, input.BuildID)
	if err != nil {
		return getCloudBuildOutput{}, err
	}

	marshaler := protojson.MarshalOptions{
		UseProtoNames: true,
		Indent:        "  ",
	}
	buildJSON, err := marshaler.Marshal(build)
	if err != nil {
		return getCloudBuildOutput{}, fmt.Errorf("json marshal: %w", err)
	}

	output := getCloudBuildOutput{
		BuildID:   input.BuildID,
		Status:    build.GetStatus().String(),
		BuildJSON: string(buildJSON),
	}

	return output, nil
}

type getCloudBuildLogsInput struct {
	BuildID string `json:"build_id" jsonschema:"The Build ID of the build.`
}

func (i getCloudBuildLogsInput) validate() error {
	var errs []error
	if i.BuildID == "" {
		errs = append(errs, errors.New("build_id is required."))
	}
	return errors.Join(errs...)
}

type getCloudBuildLogsOutput struct {
	Logs []string `json:"logs" jsonschema:"The log lines."`
}

func (d *dh) getCloudBuildLogsTool(ctx tool.Context, input getCloudBuildLogsInput) (output getCloudBuildLogsOutput, err error) {
	defer func() {
		if err != nil {
			fmt.Fprintf(os.Stderr, "*** ERROR calling get_cloud_build_logs: %v\n", err)
		}
	}()

	if err := input.validate(); err != nil {
		return getCloudBuildLogsOutput{}, err
	}

	build, err := getCloudBuild(ctx, d.ProjectID, d.Region, input.BuildID)
	if err != nil {
		return getCloudBuildLogsOutput{}, err
	}

	storageClient, err := storage.NewClient(ctx)
	if err != nil {
		return getCloudBuildLogsOutput{}, fmt.Errorf("storage.NewClient: %w", err)
	}
	defer storageClient.Close()

	bucket := strings.TrimPrefix(build.LogsBucket, "gs://")
	object := fmt.Sprintf("log-%s.txt", input.BuildID)

	rc, err := storageClient.Bucket(bucket).Object(object).NewReader(ctx)
	if err != nil {
		return getCloudBuildLogsOutput{}, fmt.Errorf("getting logs object (bucket %q object %q): %w", bucket, object, err)
	}
	defer rc.Close()

	logBlob, err := io.ReadAll(io.LimitReader(rc, maxLogs))
	lines := strings.Split(string(logBlob), "\n")

	output = getCloudBuildLogsOutput{
		Logs: lines,
	}

	return output, nil
}

type fetchTestOutputInput struct {
	Filename string `json:"test_output_filename" jsonschema:"The test output filename in the form <BUILD_ID>_test_log.xml`
}

func (i fetchTestOutputInput) validate() error {
	var errs []error
	if i.Filename == "" {
		errs = append(errs, errors.New("test_output_filename is required."))
	}
	return errors.Join(errs...)
}

type fetchTestOutputOutput struct {
	TestOutput string `json:"test_output" jsonschema:"The output test logs.`
}

func (d *dh) fetchTestOutputTool(ctx tool.Context, input fetchTestOutputInput) (fetchTestOutputOutput, error) {
	if err := input.validate(); err != nil {
		return fetchTestOutputOutput{}, err
	}
	storageClient, err := storage.NewClient(ctx)
	if err != nil {
		return fetchTestOutputOutput{}, fmt.Errorf("storage.NewClient: %w", err)
	}
	defer storageClient.Close()

	bucket := strings.TrimPrefix(d.SubBuildTestOutputBucket, "gs://")
	object := input.Filename

	rc, err := storageClient.Bucket(bucket).Object(object).NewReader(ctx)
	if err != nil {
		return fetchTestOutputOutput{}, fmt.Errorf("getting logs object (bucket %q object %q): %w", bucket, object, err)
	}
	defer rc.Close()

	blob, err := io.ReadAll(io.LimitReader(rc, maxTestOutput))

	output := fetchTestOutputOutput{
		TestOutput: string(blob),
	}

	return output, nil
}

type fetchProvenanceInput struct {
	BuildID string `json:"build_id" jsonschema:"The Build ID of the build.`
}

func (i fetchProvenanceInput) validate() error {
	var errs []error
	if i.BuildID == "" {
		errs = append(errs, errors.New("build_id is required."))
	}
	return errors.Join(errs...)
}

type fetchProvenanceOutput struct {
	Provenances []string `json:"provenances" jsonschema:"The provenance.`
}

func (d *dh) fetchProvenanceTool(ctx tool.Context, input fetchProvenanceInput) (fetchProvenanceOutput, error) {
	if err := input.validate(); err != nil {
		return fetchProvenanceOutput{}, err
	}

	// Get the list of artifacts from the build.
	build, err := getCloudBuild(ctx, d.ProjectID, d.Region, input.BuildID)
	if err != nil {
		return fetchProvenanceOutput{}, err
	}
	if build.GetStatus() != cloudbuildpb.Build_SUCCESS {
		return fetchProvenanceOutput{}, errors.New("build status must be SUCCESS to fetch provenance")
	}

	// TODO: Add source provenance.
	// if prov := build.GetSourceProvenance(); prov != nil {
	// 	fmt.Printf("TODO")
	// }

	client, err := containeranalysis.NewClient(ctx)
	if err != nil {
		return fetchProvenanceOutput{}, fmt.Errorf("containeranalysis.NewClient: %w", err)
	}
	defer client.Close()

	const magicArtifactAnalysisPrefix = "intoto_"
	greq := &grafeas.ListOccurrencesRequest{
		Parent: "projects/" + d.ProjectID,
		Filter: fmt.Sprintf("noteId=%q", magicArtifactAnalysisPrefix+input.BuildID),
	}
	var occurrences []*grafeas.Occurrence
	it := client.GetGrafeasClient().ListOccurrences(ctx, greq)
	for {
		occ, err := it.Next()
		if err == iterator.Done {
			break
		}
		if err != nil {
			return fetchProvenanceOutput{}, fmt.Errorf("iterating occurrences: %w", err)
		}
		occurrences = append(occurrences, occ)
	}

	marshaler := protojson.MarshalOptions{
		UseProtoNames: true,
		Indent:        "  ",
	}
	var output fetchProvenanceOutput
	for _, occ := range occurrences {
		occjson, err := marshaler.Marshal(occ)
		if err != nil {
			return fetchProvenanceOutput{}, fmt.Errorf("marshalling occurence: %w", err)
		}
		output.Provenances = append(output.Provenances, string(occjson))
	}
	return output, nil
}

func cloudBuildClient(ctx context.Context, region string) (*cloudbuild.Client, error) {
	endpoint := fmt.Sprintf("%s-cloudbuild.googleapis.com:443", region)
	return cloudbuild.NewClient(ctx, option.WithEndpoint(endpoint))
}

func getCloudBuild(ctx context.Context, projectID, region, buildID string) (*cloudbuildpb.Build, error) {
	client, err := cloudBuildClient(ctx, region)
	if err != nil {
		return nil, err
	}
	defer client.Close()

	gbReq := &cloudbuildpb.GetBuildRequest{
		Name:      fmt.Sprintf("projects/%s/locations/%s/builds/%s", projectID, region, buildID),
		ProjectId: projectID,
		Id:        buildID,
	}

	return client.GetBuild(ctx, gbReq)
}
